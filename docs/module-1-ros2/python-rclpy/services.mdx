---
sidebar_position: 5
title: Services (Request/Response)
description: Implement synchronous request/response communication
keywords: [ros2, python, services, request, response, rpc]
---

# Services (Request/Response)

Implement synchronous request/response communication for on-demand computations and queries.

## What are Services?

:::tip Pattern Overview

**Services** implement request/response (RPC) communication. A client sends a request and waits for a response.

- **Synchronous**: Client blocks until response
- **One-to-one**: One request, one response
- **Use cases**: Queries, computations, commands with feedback

:::

## Services vs Topics

| Feature | Topics | Services |
|---------|--------|----------|
| **Pattern** | Many-to-many | One-to-one |
| **Direction** | One-way | Two-way |
| **Timing** | Async | Sync |
| **Use case** | Data streams | On-demand queries |

## Service Definitions

Services use `.srv` files (request above `---`, response below):

**Example**: `AddTwoInts.srv`
```
int64 a
int64 b
---
int64 sum
```

## Creating a Service Server

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class AddTwoIntsServer(Node):
    def __init__(self):
        super().__init__('add_two_ints_server')

        self.srv = self.create_service(
            AddTwoInts,
            'add_two_ints',
            self.add_callback
        )

    def add_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'{request.a} + {request.b} = {response.sum}')
        return response  # Must return response

def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsServer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

## Creating a Service Client

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class AddTwoIntsClient(Node):
    def __init__(self):
        super().__init__('add_two_ints_client')

        self.client = self.create_client(AddTwoInts, 'add_two_ints')

        # Wait for service
        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for service...')

    def send_request(self, a, b):
        request = AddTwoInts.Request()
        request.a = a
        request.b = b

        # Call async
        future = self.client.call_async(request)

        return future

def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsClient()

    future = node.send_request(10, 20)

    # Wait for result
    rclpy.spin_until_future_complete(node, future)

    if future.result():
        response = future.result()
        node.get_logger().info(f'Result: {response.sum}')

    node.destroy_node()
    rclpy.shutdown()
```

## Asynchronous Callbacks

```python
class AsyncClient(Node):
    def __init__(self):
        super().__init__('async_client')
        self.client = self.create_client(AddTwoInts, 'add_two_ints')

    def send_request(self, a, b):
        request = AddTwoInts.Request()
        request.a = a
        request.b = b

        future = self.client.call_async(request)
        future.add_done_callback(self.response_callback)

    def response_callback(self, future):
        try:
            response = future.result()
            self.get_logger().info(f'Result: {response.sum}')
        except Exception as e:
            self.get_logger().error(f'Service call failed: {e}')
```

## Error Handling

### Server-Side

```python
def service_callback(self, request, response):
    try:
        # Validate
        if request.a < 0:
            response.success = False
            response.message = 'Negative inputs not allowed'
            return response

        # Process
        response.sum = request.a + request.b
        response.success = True
        return response

    except Exception as e:
        self.get_logger().error(f'Error: {e}')
        response.success = False
        return response
```

### Client-Side

```python
def call_service_safe(self, a, b):
    # Check service availability
    if not self.client.wait_for_service(timeout_sec=5.0):
        self.get_logger().error('Service not available')
        return None

    # Call with timeout
    future = self.client.call_async(request)
    rclpy.spin_until_future_complete(self, future, timeout_sec=10.0)

    if future.done():
        try:
            return future.result()
        except Exception as e:
            self.get_logger().error(f'Failed: {e}')
            return None
```

## Common Service Patterns

### Trigger Service

```python
from std_srvs.srv import Trigger

def trigger_callback(self, request, response):
    try:
        self.reset_robot()
        response.success = True
        response.message = 'Robot reset'
    except Exception as e:
        response.success = False
        response.message = str(e)
    return response
```

### SetBool Service

```python
from example_interfaces.srv import SetBool

def set_mode_callback(self, request, response):
    self.autonomous_mode = request.data
    response.success = True
    response.message = f'Mode: {"auto" if request.data else "manual"}'
    return response
```

## Testing

```bash
# List services
ros2 service list

# Call from CLI
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 5, b: 3}"

# Show service type
ros2 service type /add_two_ints
```

## Best Practices

:::tip Service Best Practices

1. **Keep fast** - < 100ms ideal
2. **Use timeouts** - Don't wait forever
3. **Validate inputs** - Check request parameters
4. **Return errors** - Use success/message fields
5. **Don't stream** - Use topics for continuous data

:::

## When to Use Services

**✅ Use for:**
- Queries ("Get battery level")
- Computations ("Calculate trajectory")
- Commands ("Enable motor")

**❌ Don't use for:**
- Continuous data (use topics)
- Long tasks (use actions)

## Key Takeaways

:::note Summary

- **Services** = Request/Response (RPC)
- **Synchronous**: Client waits for response
- **Server**: `create_service()` with callback
- **Client**: `create_client()` + `call_async()`
- **Error handling**: Validate, timeout, try/catch
- **Testing**: `ros2 service list/call`

:::

---

**Next**: [Actions →](./actions)

**Previous**: [← Publishers/Subscribers](./publishers-subscribers)
