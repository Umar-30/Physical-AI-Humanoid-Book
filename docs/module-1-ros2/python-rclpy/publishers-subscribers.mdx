---
sidebar_position: 4
title: Publishers and Subscribers
description: Implementing publish-subscribe communication in rclpy
keywords: [ros2, python, publisher, subscriber, topics, pubsub]
---

# Publishers and Subscribers

Master the publish-subscribe pattern - the most common communication mechanism in ROS 2.

## The Publish-Subscribe Pattern

:::tip Pattern Overview

**Publishers** send messages to topics. **Subscribers** receive messages from topics. They are decoupled - publishers don't know about subscribers.

- **Many-to-many**: Multiple publishers and subscribers per topic
- **Asynchronous**: Fire-and-forget
- **Continuous data**: Sensor streams, telemetry, states

:::

## Creating a Publisher

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')

        # Create publisher
        self.publisher = self.create_publisher(String, 'chatter', 10)

        # Timer to publish at 2 Hz
        self.timer = self.create_timer(0.5, self.timer_callback)
        self.count = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.count}'
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.count += 1

def main(args=None):
    rclpy.init(args=args)
    node = MinimalPublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### Publisher API

```python
self.publisher = self.create_publisher(
    msg_type=String,       # Message type
    topic='my_topic',      # Topic name
    qos_profile=10         # Queue size
)

# Publish
msg = String()
msg.data = 'Hello'
self.publisher.publish(msg)
```

## Creating a Subscriber

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')

        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10
        )

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalSubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

## Common Message Types

### std_msgs
```python
from std_msgs.msg import String, Int32, Float64, Bool

msg = String(data='Hello')
msg = Int32(data=42)
msg = Float64(data=3.14)
msg = Bool(data=True)
```

### geometry_msgs
```python
from geometry_msgs.msg import Twist, Point, Pose

# Velocity command
cmd = Twist()
cmd.linear.x = 1.0    # m/s forward
cmd.angular.z = 0.5   # rad/s rotation

# Position
point = Point(x=1.0, y=2.0, z=0.0)

# Pose (position + orientation)
pose = Pose()
pose.position.x = 1.0
pose.orientation.w = 1.0  # No rotation
```

### sensor_msgs
```python
from sensor_msgs.msg import JointState, LaserScan

# Joint states
joint_state = JointState()
joint_state.name = ['joint1', 'joint2']
joint_state.position = [0.0, 1.57]
joint_state.velocity = [0.1, 0.0]

# Laser scan
scan = LaserScan()
scan.angle_min = -1.57
scan.angle_max = 1.57
scan.ranges = [1.0, 1.1, 1.2, ...]
```

## Real-World Example: Joint Publisher

```python
from sensor_msgs.msg import JointState
import math

class JointPublisher(Node):
    def __init__(self):
        super().__init__('joint_publisher')

        self.publisher = self.create_publisher(JointState, 'joint_states', 10)
        self.timer = self.create_timer(0.02, self.publish_joints)  # 50 Hz

        self.joint_names = [
            'left_shoulder', 'left_elbow',
            'right_shoulder', 'right_elbow'
        ]
        self.time = 0.0

    def publish_joints(self):
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = self.joint_names

        # Animate wave motion
        wave = 0.5 * math.sin(2 * math.pi * 0.5 * self.time)
        msg.position = [wave, -0.5, 0.0, -0.5]

        self.publisher.publish(msg)
        self.time += 0.02
```

## Publisher + Subscriber in One Node

```python
class EchoNode(Node):
    def __init__(self):
        super().__init__('echo_node')

        # Subscribe
        self.subscription = self.create_subscription(
            String, 'input', self.callback, 10
        )

        # Publish
        self.publisher = self.create_publisher(String, 'output', 10)

    def callback(self, msg):
        # Process and republish
        output = String()
        output.data = msg.data.upper()
        self.publisher.publish(output)
```

## Quality of Service (QoS)

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

# Custom QoS
qos = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,  # or BEST_EFFORT
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)

self.publisher = self.create_publisher(String, 'topic', qos)
```

**Presets**:
```python
from rclpy.qos import qos_profile_sensor_data

# For sensors (best effort)
self.pub = self.create_publisher(LaserScan, 'scan', qos_profile_sensor_data)
```

## Timestamps and Headers

Always set timestamps for messages with headers:

```python
from std_msgs.msg import Header

msg.header.stamp = self.get_clock().now().to_msg()
msg.header.frame_id = 'base_link'
```

## Testing

```bash
# List topics
ros2 topic list

# Echo messages
ros2 topic echo /chatter

# Check rate
ros2 topic hz /chatter

# Publish from CLI
ros2 topic pub /chatter std_msgs/msg/String "{data: 'hello'}"
```

## Best Practices

:::tip Pub/Sub Best Practices

1. **Keep callbacks fast** - Don't block (&lt; 1ms)
2. **Use appropriate QoS** - BEST_EFFORT for sensors, RELIABLE for commands
3. **Limit queue size** - Avoid KEEP_ALL
4. **Set timestamps** - Always use `get_clock().now()`
5. **Use timers** - Don't use `sleep()` in loops
6. **Check subscriber count** (optional):
   ```python
   if self.publisher.get_subscription_count() > 0:
       self.publisher.publish(msg)
   ```

:::

## Key Takeaways

:::note Summary

- **Pub/Sub** is asynchronous, many-to-many communication
- **Publisher**: `create_publisher()` + `publish()`
- **Subscriber**: `create_subscription()` + callback
- **Message types**: std_msgs, geometry_msgs, sensor_msgs
- **QoS**: Controls reliability and history
- **Headers**: Need timestamps and frame_ids
- **Testing**: `ros2 topic list/echo/hz`

:::

---

**Next**: [Services →](./services)

**Previous**: [← Package Setup](./package-setup)
